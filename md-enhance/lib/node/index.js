import { utoa as j, deepMerge as W, Logger as it, getLocales as at, mergeViteConfig as lt, addViteSsrNoExternal as ct, addCustomElement as B, addViteOptimizeDepsExclude as U, addViteSsrExternal as T, addViteOptimizeDepsInclude as te, chainWebpack as pt } from "vuepress-shared/node"; import M from "markdown-it/lib/token.js"; import mt from "markdown-it/lib/helpers/parse_link_label.js"; import { ensureLeadingSlash as ne, resolveLocalePath as oe, ensureEndingSlash as ft } from "@vuepress/shared"; import { createRequire as re } from "node:module"; import se from "katex"; import { dirname as ut } from "node:path"; import { mathjax as ie } from "mathjax-full/js/mathjax.js"; import { mathjax as ao } from "mathjax-full/js/mathjax.js"; import { TeX as dt } from "mathjax-full/js/input/tex.js"; import { TeX as co } from "mathjax-full/js/input/tex.js"; import { CHTML as ht } from "mathjax-full/js/output/chtml.js"; import { CHTML as mo } from "mathjax-full/js/output/chtml.js"; import { SVG as gt } from "mathjax-full/js/output/svg.js"; import { SVG as uo } from "mathjax-full/js/output/svg.js"; import { liteAdaptor as bt } from "mathjax-full/js/adaptors/liteAdaptor.js"; import { AssistiveMmlHandler as yt } from "mathjax-full/js/a11y/assistive-mml.js"; import { RegisterHTMLHandler as kt } from "mathjax-full/js/handlers/html.js"; import { AllPackages as $t } from "mathjax-full/js/input/tex/AllPackages.js"; import { path as S, fs as ae, hash as vt, getDirname as _t, logger as xt, colors as E } from "@vuepress/utils"; import { useSassPalettePlugin as Ct } from "vuepress-plugin-sass-palette"; const O = (e, { name: t, marker: o = "`", validate: n = a => a.trim().split(" ", 2)[0] === t, openRender: r = (a, i, l, c, f) => (a[i].attrJoin("class", t), f.renderToken(a, i, l)), closeRender: s = (a, i, l, c, f) => f.renderToken(a, i, l) } = { name: "" }) => { const a = o[0], i = o.length, l = (c, f, p, b) => { let m = c.bMarks[f] + c.tShift[f], h = c.eMarks[f]; if (a !== c.src[m]) return !1; let u = m + 1; for (; u <= h && o[(u - m) % i] === c.src[u];)u += 1; const g = Math.floor((u - m) / i); if (g < 3) return !1; u -= (u - m) % i; const _ = c.src.slice(m, u), k = c.src.slice(u, h); if (!n(k, _)) return !1; if (b) return !0; let $ = f, v = !1; for (; $ < p && ($ += 1, m = c.bMarks[$] + c.tShift[$], h = c.eMarks[$], !(m < h && c.sCount[$] < c.blkIndent));)if (a === c.src[m] && c.sCount[$] - c.blkIndent < 4) { for (u = m + 1; u <= h && o[(u - m) % i] === c.src[u]; u++); if (Math.floor((u - m) / i) >= g && (u -= (u - m) % i, u = c.skipSpaces(u), u >= h)) { v = !0; break } } const d = c.parentType, y = c.lineMax; c.parentType = "container", c.lineMax = $; const C = c.push(`container_${t}_open`, "div", 1); C.markup = _, C.block = !0, C.info = k, C.map = [f, $], c.md.block.tokenize(c, f + 1, $); const x = c.push(`container_${t}_close`, "div", -1); return x.markup = c.src.slice(m, u), x.block = !0, c.parentType = d, c.lineMax = y, c.line = $ + (v ? 1 : 0), !0 }; e.block.ruler.before("fence", `container_${t}`, l, { alt: ["paragraph", "reference", "blockquote", "list"] }), e.renderer.rules[`container_${t}_open`] = r, e.renderer.rules[`container_${t}_close`] = s }, le = e => {
  ["left", "center", "right", "justify"].forEach(t => e.use(o => O(o, {
    name: t, openRender: () => `<div style="text-align:${t}">
`})))
}, wt = /[^\t\n\f />"'=]/, jt = " ", Mt = "=", ce = ".", St = "#", I = (e, t, { left: o, right: n, allowed: r }) => { let s = "", a = "", i = !0, l = !1; const c = []; for (let f = t + o.length; f < e.length; f++) { if (e.slice(f, f + n.length) === n) { s !== "" && c.push([s, a]); break } const p = e.charAt(f); if (p === Mt && i) { i = !1; continue } if (p === ce && s === "") { e.charAt(f + 1) === ce ? (s = "css-module", f += 1) : s = "class", i = !1; continue } if (p === St && s === "") { s = "id", i = !1; continue } if (p === '"' && a === "") { l = !0; continue } if (p === '"' && l) { l = !1; continue } if (p === jt && !l) { if (s === "") continue; c.push([s, a]), s = "", a = "", i = !0; continue } if (!(i && p.search(wt) === -1)) { if (i) { s += p; continue } a += p } } return r.length ? c.filter(([f]) => r.some(p => p instanceof RegExp ? p.test(f) : p === f)) : c }, A = (e, t) => { t && e.forEach(o => { const [n, r] = o; n === "class" ? t.attrJoin("class", r) : n === "css-module" ? t.attrJoin("css-module", r) : t.attrPush(o) }) }, R = (e, { left: t, right: o }) => n => { const r = t.length, s = o.length, a = r + 1 + s; if (!n || typeof n != "string" || n.length < a) return !1; const i = m => { const h = m.charAt(r) === ".", u = m.charAt(r) === "#"; return h || u ? m.length >= a + 1 : m.length >= a }; let l, c, f, p; const b = a - s; switch (e) { case "start": f = n.slice(0, r), l = f === t ? 0 : -1, c = l === -1 ? -1 : n.indexOf(o, b), p = n.charAt(c + s), p && o.indexOf(p) !== -1 && (c = -1); break; case "end": l = n.lastIndexOf(t), c = l === -1 ? -1 : n.indexOf(o, l + b), c = c === n.length - s ? c : -1; break; case "only": f = n.slice(0, r), l = f === t ? 0 : -1, f = n.slice(n.length - s), c = f === o ? n.length - s : -1; break }return l !== -1 && c !== -1 && i(n.substring(l, c + s)) }, Ot = (e, { left: t, right: o }) => { const n = z(t), r = z(o), s = e.search(new RegExp(`[ \\n]?${n}[^${n}${r}]+${r}$`)); return s !== -1 ? e.slice(0, s) : e }, L = (e, t) => { if (e[t].type === "softbreak") return null; if (e[t].nesting === 0) return e[t]; const o = e[t].level, n = e[t].type.replace("_close", "_open"); for (; t >= 0; --t)if (e[t].type === n && e[t].level === o) return e[t]; return null }, It = (e, t) => t >= 0 ? e[t] : e[e.length + t], At = e => Array.isArray(e) && Boolean(e.length) && e.every(t => typeof t == "object"), Pt = e => Array.isArray(e) && Boolean(e.length) && e.every(t => typeof t == "function"), z = e => e.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), Rt = e => [{ name: "fenced code blocks", tests: [{ shift: 0, block: !0, info: R("end", e) }], transform: (t, o) => { const n = t[o]; let r = ""; const s = n.info.match(/{(?:[\d,-]+)}/); s && (n.info = n.info.replace(s[0], ""), r = s[0]); const a = n.info.lastIndexOf(e.left), i = I(n.info, a, e); A(i, n), n.info = `${Ot(n.info, e)} ${r}` } }, { name: "inline nesting 0", tests: [{ shift: 0, type: "inline", children: [{ shift: -1, type: t => t === "image" || t === "code_inline" }, { shift: 0, type: "text", content: R("start", e) }] }], transform: (t, o, n) => { const r = t[o].children[n], s = r.content.indexOf(e.right), a = t[o].children[n - 1], i = I(r.content, 0, e); A(i, a), r.content.length === s + e.right.length ? t[o].children.splice(n, 1) : r.content = r.content.slice(s + e.right.length) } }, { name: "tables", tests: [{ shift: 0, type: "table_close" }, { shift: 1, type: "paragraph_open" }, { shift: 2, type: "inline", content: R("only", e) }], transform: (t, o) => { const n = t[o + 2], r = L(t, o), s = I(n.content, 0, e); A(s, r), t.splice(o + 1, 3) } }, { name: "inline attributes", tests: [{ shift: 0, type: "inline", children: [{ shift: -1, nesting: -1 }, { shift: 0, type: "text", content: R("start", e) }] }], transform: (t, o, n) => { const r = t[o].children[n], { content: s } = r, a = I(s, 0, e), i = L(t[o].children, n - 1); A(a, i), r.content = s.slice(s.indexOf(e.right) + e.right.length) } }, { name: "list softbreak", tests: [{ shift: -2, type: "list_item_open" }, { shift: 0, type: "inline", children: [{ position: -2, type: "softbreak" }, { position: -1, type: "text", content: R("only", e) }] }], transform: (t, o, n) => { const r = t[o].children[n], s = I(r.content, 0, e); let a = o - 2; for (; t[a - 1] && t[a - 1].type !== "ordered_list_open" && t[a - 1].type !== "bullet_list_open";)a--; A(s, t[a - 1]), t[o].children = t[o].children.slice(0, -2) } }, { name: "list double softbreak", tests: [{ shift: 0, type: t => t === "bullet_list_close" || t === "ordered_list_close" }, { shift: 1, type: "paragraph_open" }, { shift: 2, type: "inline", content: R("only", e), children: t => t.length === 1 }, { shift: 3, type: "paragraph_close" }], transform: (t, o) => { const n = t[o + 2], r = I(n.content, 0, e), s = L(t, o); A(r, s), t.splice(o + 1, 3) } }, { name: "list item end", tests: [{ shift: -2, type: "list_item_open" }, { shift: 0, type: "inline", children: [{ position: -1, type: "text", content: R("end", e) }] }], transform: (t, o, n) => { const r = t[o].children[n], { content: s } = r, a = I(s, s.lastIndexOf(e.left), e); A(a, t[o - 2]); const i = s.slice(0, s.lastIndexOf(e.left)); r.content = i[i.length - 1] === " " ? i.slice(0, -1) : i } }, {
  name: `
{.a} softbreak then curly in start`, tests: [{ shift: 0, type: "inline", children: [{ position: -2, type: "softbreak" }, { position: -1, type: "text", content: R("only", e) }] }], transform: (t, o, n) => { const r = t[o].children[n], s = I(r.content, 0, e); let a = o + 1; for (; t[a + 1] && t[a + 1].nesting === -1;)a++; const i = L(t, a); A(s, i), t[o].children = t[o].children.slice(0, -2) }
}, { name: "horizontal rule", tests: [{ shift: 0, type: "paragraph_open" }, { shift: 1, type: "inline", children: t => t.length === 1, content: t => t.match(new RegExp(`^ {0,3}[-*_]{3,} ?${z(e.left)}[^${z(e.right)}]`)) !== null }, { shift: 2, type: "paragraph_close" }], transform: (t, o) => { const n = t[o]; n.type = "hr", n.tag = "hr", n.nesting = 0; const { content: r } = t[o + 1], s = r.lastIndexOf(e.left), a = I(r, s, e); A(a, n), n.markup = r, t.splice(o + 1, 2) } }, { name: "end of block", tests: [{ shift: 0, type: "inline", children: [{ position: -1, content: R("end", e), type: t => t !== "code_inline" && t !== "math_inline" }] }], transform: (t, o, n) => { const r = t[o].children[n], { content: s } = r, a = I(s, s.lastIndexOf(e.left), e); let i = o + 1; for (; t[i + 1] && t[i + 1].nesting === -1;)i++; const l = L(t, i); A(a, l); const c = s.slice(0, s.lastIndexOf(e.left)); r.content = c[c.length - 1] === " " ? c.slice(0, -1) : c } }], V = (e, t, o) => { var n, r; const s = { match: !1, pos: null }, a = o.shift !== void 0 ? t + o.shift : o.position; if (o.shift !== void 0 && a < 0) return s; const i = It(e, a); if (i === void 0) return s; for (const l of Object.keys(o)) { if (l === "shift" || l === "position") continue; if (i[l] === void 0) return s; if (l === "children" && At(o.children)) { if (((n = i.children) == null ? void 0 : n.length) === 0) return s; let f; const p = o.children, b = i.children; if (p != null && p.every(m => m.position !== void 0)) { if (f = p.every(m => V(b, m.position, m).match), f) { const m = ((r = p[p.length - 1]) == null ? void 0 : r.position) || 0; s.pos = m >= 0 ? m : b.length + m } } else for (let m = 0; m < b.length; m++)if (f = p.every(h => V(b, m, h).match), f) { s.pos = m; break } if (f === !1) return s; continue } const c = o[l]; switch (typeof c) { case "boolean": case "number": case "string": if (i[l] !== c) return s; break; case "function": if (!c(i[l])) return s; break; case "object": if (Pt(c)) { if (c.every(f => f(i[l])) === !1) return s; break } continue; default: throw new Error(`Unknown type of pattern test (key: ${l}). Test should be of type boolean, number, string, function or array of functions.`) } } return s.match = !0, s }, pe = (e, { left: t = "{", right: o = "}", allowed: n = [] } = {}) => { const r = Rt({ left: t, right: o, allowed: n }), s = a => { const i = a.tokens; for (let l = 0; l < i.length; l++)for (let c = 0; c < r.length; c++) { const f = r[c]; let p = null; f.tests.every(b => { const m = V(i, l, b); return m.pos !== null && (p = m.pos), m.match }) && (f.transform(i, l, p), (f.name === "inline attributes" || f.name === "inline nesting 0") && c--) } }; e.core.ruler.before("linkify", "curly_attributes", s) }, me = e => { O(e, { name: "chart", openRender: (t, o) => { const n = t[o].info.trimStart().slice(5).trim(), r = `chart-${o}`; let s = "{}", a = ""; for (let i = o; i < t.length; i++) { const { type: l, content: c, info: f } = t[i]; if (l === "container_chart_close") break; c && (l === "fence" && (f === "json" ? (s = j(c), a = "json") : (f === "js" || f === "javascript") && (s = j(c), a = "js")), t[i].type = "chart_empty", t[i].hidden = !0) } return `<ChartJS id="${r}" config="${s}" ${n ? `title="${encodeURIComponent(n)}" ` : ""}type="${a}">` }, closeRender: () => "</ChartJS>" }) }, fe = { useBabel: !1, jsLib: [], cssLib: [], codepenLayout: "left", codepenEditors: "101", babel: "https://unpkg.com/@babel/standalone/babel.min.js", vue: "https://unpkg.com/vue/dist/vue.global.prod.js", react: "https://unpkg.com/react/umd/react.production.min.js", reactDOM: "https://unpkg.com/react-dom/umd/react-dom.production.min.js" }, q = e => t => O(t, {
  name: e, openRender: (o, n) => {
    const r = o[n].info.trimStart().slice(e.length).trim(); let s = ""; const a = {}; for (let i = n; i < o.length; i++) { const { type: l, content: c, info: f } = o[i]; if (l === `container_${e}_close`) break; c && l === "fence" && (f === "json" ? s = j(c) : a[f] = c) } return `
<CodeDemo id="code-demo-${n}" type="${e.split("-")[0]}"${r ? ` title="${encodeURIComponent(r)}"` : ""}${s ? ` config="${s}"` : ""} code="${j(JSON.stringify(a))}">
`}, closeRender: () => "</CodeDemo>"
}), ue = q("normal-demo"), de = q("vue-demo"), he = q("react-demo"), H = (e, { name: t, component: o, getter: n } = { name: "tabs", component: "Tabs", getter: () => [] }) => {
  const r = "@tab", s = (i, l, c, f) => { let p = i.bMarks[l] + i.tShift[l], b = i.eMarks[l]; if (i.src[p] !== ":") return !1; let m = p + 1; for (; m <= b && i.src[m] === ":";)m += 1; const h = m - p; if (h < 3) return !1; const u = i.src.slice(p, m), g = i.src.slice(m, b), [_, k = ""] = g.split("#", 2); if (_.trim() !== t) return !1; if (f) return !0; let $ = l, v = !1; for (; $ < c && ($ += 1, p = i.bMarks[$] + i.tShift[$], b = i.eMarks[$], !(p < b && i.sCount[$] < i.blkIndent));)if (i.src[p] === ":" && i.sCount[$] - i.blkIndent < 4) { for (m = p + 1; m <= b && i.src[m] === ":"; m++); if (m - p >= h && (m = i.skipSpaces(m), m >= b)) { v = !0; break } } const d = i.parentType, y = i.lineMax; i.parentType = `${t}_tabs`, i.lineMax = $ - (v ? 1 : 0); const C = i.push(`${t}_tabs_open`, o, 1); C.markup = u, C.block = !0, C.info = _, C.meta = { id: k.trim() }, C.map = [l, $ - (v ? 1 : 0)], i.md.block.tokenize(i, l + 1, $ - (v ? 1 : 0)); const x = i.push(`${t}_tabs_close`, o, -1); return x.markup = i.src.slice(p, m), x.block = !0, i.parentType = d, i.lineMax = y, i.line = $ + (v ? 1 : 0), !0 }, a = (i, l, c, f) => { let p = i.bMarks[l] + i.tShift[l], b = i.eMarks[l]; if (i.src.charAt(p) !== "@") return !1; let m; for (m = 0; m < r.length; m++)if (r[m] !== i.src[p + m]) return !1; const h = i.src.slice(p, p + m), u = i.src.slice(p + m, b); if (f) return !0; let g = l, _ = !1; for (; g < c && (g += 1, p = i.bMarks[g] + i.tShift[g], b = i.eMarks[g], !(p < b && i.sCount[g] < i.blkIndent));)if (i.src[p] === "@" && i.sCount[g] <= i.sCount[l]) { let x = !0; for (m = 0; m < r.length; m++)if (r[m] !== i.src[p + m]) { x = !1; break } if (x) { _ = !0, g -= 1; break } } const k = i.parentType, $ = i.lineMax; i.parentType = "tab", i.lineMax = g; const v = i.push("tab_open", "template", 1), [d, y] = u.replace(/^:active/, "").split("#", 2); v.block = !0, v.markup = h, v.info = d.trim(), v.meta = { active: u.includes(":active") }, y && (v.meta.value = y.trim()), v.map = [l, g], i.md.block.tokenize(i, l + 1, g); const C = i.push("tab_close", "template", -1); return C.block = !0, C.markup = "", i.parentType = k, i.lineMax = $, i.line = g + (_ ? 1 : 0), !0 }; e.block.ruler.before("fence", `${t}_tabs`, s, { alt: ["paragraph", "reference", "blockquote", "list"] }), e.block.ruler.__rules__.find(({ name: i }) => i === "tab") || e.block.ruler.before("fence", "tab", a, { alt: ["paragraph", "reference", "blockquote", "list"] }), e.renderer.rules[`${t}_tabs_open`] = (i, l, c, f, p) => {
    const { meta: b } = i[l], m = [], h = n(i, l, c, f, p); let u = -1, g = !1; for (let k = l; k < i.length; k++) { const { block: $, meta: v, type: d, info: y } = i[k]; if ($) { if (d === `${t}_tabs_close`) break; if (d === `${t}_tabs_open`) continue; if (d === "tab_open") { v.active && (u = m.length), i[k].attrPush([`#tab${m.length}`, "{ title, value, isActive }"]), g = !0, m.push({ title: y, ...v.value ? { value: v.value } : {} }); continue } if (d === "tab_close") continue; g || (i[k].type = `${t}_tabs_empty`, i[k].hidden = !0) } } const _ = m.map((k, $) => ({ ...k, ...h[$] })); return `<${o} id="${l}" :data='${JSON.stringify(_).replace(/'/g, "&#39")}'${u !== -1 ? ` :active="${u}"` : ""}${b.id ? ` tab-id="${b.id}"` : ""}>
`}, e.renderer.rules[`${t}_tabs_close`] = () => `</${o}>
`}, ge = e => { H(e, { name: "code-tabs", component: "CodeTabs", getter: (t, o) => { let n = !1, r = !1; const s = []; for (let a = o; a < t.length; a++) { const { block: i, type: l } = t[a]; if (i) { if (l === "code-tabs_tabs_close") break; if (l === "tab_close") { n = !1; continue } if (l === "tab_open") { n = !0, r = !1; continue } if (n && l === "fence" && !r) { r = !0; continue } t[a].type = "code_tab_empty", t[a].hidden = !0 } } return s } }) }, be = (e, t) => { const o = e[t], n = `echarts-${t}`, { content: r, info: s } = o, a = s.trim().split(":", 2)[1]; return `<ECharts id="${n}" config="${j(r)}"${a ? ` title="${encodeURIComponent(a)}"` : ""}></ECharts>` }, ye = e => { const t = e.renderer.rules.fence; e.renderer.rules.fence = (...o) => { const [n, r] = o, { info: s } = n[r]; return s.split(":", 2)[0] === "echarts" ? be(n, r) : t(...o) }, e.renderer.rules.echarts = be, O(e, { name: "echarts", openRender: (o, n) => { const r = o[n].info.trimStart().slice(7).trim(), s = `echarts-${n}`; let a = "{}", i = !1; for (let l = n; l < o.length; l++) { const { type: c, content: f, info: p } = o[l]; if (c === "container_echarts_close") break; f && (c === "fence" && (p === "json" ? a = f : (p === "js" || p === "javascript") && (a = f, i = !0)), o[l].type = "echarts_empty", o[l].hidden = !0) } return `<ECharts id="${s}" config="${j(a)}"${r ? ` title="${encodeURIComponent(r)}"` : ""}${i ? ' type="js"' : ""}>` }, closeRender: () => "</ECharts>" }) }, Tt = (e, t) => { e.attrs = (e.attrs || []).filter(([o]) => o !== t) }, Et = e => { var t, o; const n = (o = (t = e.attrs) == null ? void 0 : t.find(([r]) => r === "title")) == null ? void 0 : o[1]; return n ? (Tt(e, "title"), n) : e.content }, ke = (e, t = {}) => { e.core.ruler.before("linkify", "figure", o => { for (let n = 1, { length: r } = o.tokens; n < r - 1; n++) { const s = o.tokens[n]; if (s.type !== "inline" || !s.children || s.children.length !== 1 && s.children.length !== 3 || s.children.length === 1 && s.children[0].type !== "image") continue; if (s.children.length === 3) { const [f, p, b] = s.children; if (f.type !== "link_open" || p.type !== "image" || b.type !== "link_close") continue } if (n !== 0 && o.tokens[n - 1].type !== "paragraph_open" || n !== r - 1 && o.tokens[n + 1].type !== "paragraph_close") continue; const a = o.tokens[n - 1]; a.type = "figure_open", a.tag = "figure", o.tokens[n + 1].type = "figure_close", o.tokens[n + 1].tag = "figure"; const i = s.children.length === 1 ? s.children[0] : s.children[1], l = Et(i), [c] = e.parseInline(l, o.env); s.children.push(new o.Token("figcaption_open", "figcaption", 1)), s.children.push(...c.children || []), s.children.push(new o.Token("figcaption_close", "figcaption", -1)), t.focusable !== !1 && i.attrPush(["tabindex", "0"]) } }) }, $e = (e, t) => { const o = e[t], n = `flowchart-${t}`, { content: r, info: s } = o; return `<FlowChart id="${n}" code="${j(r)}" preset="${s.trim().split(":", 2)[1] || "vue"}"></FlowChart>` }, ve = e => { const t = e.renderer.rules.fence; e.renderer.rules.fence = (...o) => { const [n, r] = o, { info: s } = n[r], a = s.split(":", 2)[0]; return a === "flow" || a === "flowchart" ? $e(n, r) : t(...o) }, e.renderer.rules.flowchart = $e }, J = (e, t) => e[t].meta.subId > 0 ? `:${e[t].meta.subId}` : "", Dt = (e, t, o, n) => `${typeof n.docId == "string" ? `-${n.docId}-` : ""}${(e[t].meta.id + 1).toString()}`, Lt = (e, t) => `[${(e[t].meta.id + 1).toString()}${J(e, t)}]`, Nt = (e, t, o, n, r) => { const s = r.rules.footnoteAnchorName(e, t, o, n, r), a = r.rules.footnoteCaption(e, t, o, n, r); return `<sup class="footnote-ref"><a href="#footnote${s}">${a}</a><a class="footnote-anchor" id="footnote-ref${s}${J(e, t)}" /></sup>` }, Ft = (e, t, o) => `${o.xhtmlOut ? `<hr class="footnotes-sep" />
`: `<hr class="footnotes-sep">
`}<section class="footnotes">
<ol class="footnotes-list">
`, Ut = () => `</ol>
</section>
`, zt = (e, t, o, n, r) => `<li id="footnote${r.rules.footnoteAnchorName(e, t, o, n, r)}${J(e, t)}" class="footnote-item">`, Jt = () => `</li>
`, Gt = (e, t, o, n, r) => ` <a href="#footnote-ref${r.rules.footnoteAnchorName(e, t, o, n, r)}${J(e, t)}" class="footnote-backref">↩︎</a>`, Wt = (e, t, o, n) => { let r, s, a, i; const l = e.bMarks[t] + e.tShift[t], c = e.eMarks[t]; if (l + 4 > c || e.src.charAt(l) !== "[" || e.src.charAt(l + 1) !== "^") return !1; for (r = l + 2; r < c; r++) { if (e.src.charAt(r) === " ") return !1; if (e.src.charAt(r) === "]") break } if (r === l + 2 || r + 1 >= c || e.src.charAt(++r) !== ":") return !1; if (n) return !0; r += 1, e.env.footnotes || (e.env.footnotes = {}), e.env.footnotes.refs || (e.env.footnotes.refs = {}); const f = e.src.slice(l + 2, r - 2); e.env.footnotes.refs[`:${f}`] = -1, s = new M("footnoteReferenceOpen", "", 1), s.meta = { label: f }, s.level = e.level++, e.tokens.push(s); const p = e.bMarks[t], b = e.tShift[t], m = e.sCount[t], h = e.parentType, u = r, g = e.sCount[t] + r - (e.bMarks[t] + e.tShift[t]); for (a = e.sCount[t] + r - (e.bMarks[t] + e.tShift[t]); r < c;) { if (i = e.src.charAt(r), i === "	") a += 4 - a % 4; else if (i === " ") a += 1; else break; r += 1 } return e.tShift[t] = r - u, e.sCount[t] = a - g, e.bMarks[t] = u, e.blkIndent += 4, e.parentType = "footnote", e.sCount[t] < e.blkIndent && (e.sCount[t] += e.blkIndent), e.md.block.tokenize(e, t, o), e.parentType = h, e.blkIndent -= 4, e.tShift[t] = b, e.sCount[t] = m, e.bMarks[t] = p, s = new M("footnoteReferenceClose", "", -1), s.level = --e.level, e.tokens.push(s), !0 }, Bt = (e, t) => { let o, n, r; const s = e.posMax, a = e.pos; if (a + 2 >= s || e.src.charAt(a) !== "^" || e.src.charAt(a + 1) !== "[") return !1; const i = a + 2, l = mt(e, a + 1); return l < 0 ? !1 : (t || (e.env.footnotes || (e.env.footnotes = {}), e.env.footnotes.list || (e.env.footnotes.list = []), o = e.env.footnotes.list.length, e.md.inline.parse(e.src.slice(i, l), e.md, e.env, r = []), n = e.push("footnoteRef", "", 0), n.meta = { id: o }, e.env.footnotes.list[o] = { content: e.src.slice(i, l), tokens: r }), e.pos = l + 1, e.posMax = s, !0) }, Vt = (e, t) => {
    let o, n, r, s; const a = e.posMax, i = e.pos; if (i + 3 > a || !e.env.footnotes || !e.env.footnotes.refs || e.src.charAt(i) !== "[" || e.src.charAt(i + 1) !== "^") return !1; for (o = i + 2; o < a; o++) {
      if (e.src.charAt(o) === " " || e.src.charAt(o) === `
`) return !1; if (e.src.charAt(o) === "]") break
    } if (o === i + 2 || o >= a) return !1; o += 1; const l = e.src.slice(i + 2, o - 1); return typeof e.env.footnotes.refs[`:${l}`] > "u" ? !1 : (t || (e.env.footnotes.list || (e.env.footnotes.list = []), e.env.footnotes.refs[`:${l}`] < 0 ? (n = e.env.footnotes.list.length, e.env.footnotes.list[n] = { label: l, count: 0 }, e.env.footnotes.refs[`:${l}`] = n) : n = e.env.footnotes.refs[`:${l}`], r = e.env.footnotes.list[n].count, e.env.footnotes.list[n].count = e.env.footnotes.list[n].count + 1, s = e.push("footnoteRef", "", 0), s.meta = { id: n, subId: r, label: l }), e.pos = o, e.posMax = a, !0)
  }, qt = e => { let t, o, n, r, s, a = !1; const i = {}; if (!e.env.footnotes || (e.tokens = e.tokens.filter(c => c.type === "footnoteReferenceOpen" ? (a = !0, r = [], s = c.meta.label, !1) : c.type === "footnoteReferenceClose" ? (a = !1, i[`:${s}`] = r, !1) : (a && r.push(c), !a)), !e.env.footnotes.list)) return !1; const { list: l } = e.env.footnotes; o = new M("footnoteBlockOpen", "", 1), e.tokens.push(o); for (let c = 0, { length: f } = l; c < f; c++) { o = new M("footnoteOpen", "", 1), o.meta = { id: c, label: l[c].label }, e.tokens.push(o), l[c].tokens ? (n = [], o = new M("paragraph_open", "p", 1), o.block = !0, n.push(o), o = new M("inline", "", 0), o.children = l[c].tokens, o.content = l[c].content, n.push(o), o = new M("paragraph_close", "p", -1), o.block = !0, n.push(o)) : l[c].label ? n = i[`:${l[c].label}`] : n = [], n && (e.tokens = e.tokens.concat(n)), e.tokens[e.tokens.length - 1].type === "paragraph_close" ? t = e.tokens.pop() || null : t = null; for (let p = 0; p < (Number(l[c].count) > 0 ? l[c].count : 1); p++)o = new M("footnoteAnchor", "", 0), o.meta = { id: c, subId: p, label: l[c].label }, e.tokens.push(o); t && e.tokens.push(t), o = new M("footnoteClose", "", -1), e.tokens.push(o) } return o = new M("footnoteBlockClose", "", -1), e.tokens.push(o), !0 }, _e = e => { e.renderer.rules.footnoteRef = Nt, e.renderer.rules.footnoteBlockOpen = Ft, e.renderer.rules.footnoteBlockClose = Ut, e.renderer.rules.footnoteOpen = zt, e.renderer.rules.footnoteClose = Jt, e.renderer.rules.footnoteAnchor = Gt, e.renderer.rules.footnoteCaption = Lt, e.renderer.rules.footnoteAnchorName = Dt, e.block.ruler.before("reference", "footnoteDef", Wt, { alt: ["paragraph", "reference"] }), e.inline.ruler.after("image", "footnoteInline", Bt), e.inline.ruler.after("footnoteInline", "footnoteRef", Vt), e.core.ruler.after("inline", "footnoteTail", qt) }, xe = (e, t = {}) => {
    ["info", "note", "tip", "warning", "danger"].forEach(o => {
      e.use(O, {
        name: o, openRender: (n, r, s, a) => {
          var i; let l = n[r].info.trim().slice(o.length).trim(); if (!l) { const { filePathRelative: c } = a, f = ne(c ?? ""), p = oe(t, f); l = (i = t[p]) == null ? void 0 : i[o] } return `<div class="custom-container ${o}">
<p class="custom-container-title">${l || o}</p>
`}, closeRender: () => `</div>
`})
    }), e.use(o => O(o, {
      name: "details", openRender: (n, r, s, a) => {
        var i; let l = n[r].info.trim().slice(7).trim(); if (!l) { const { filePathRelative: c } = a, f = ne(c ?? ""), p = oe(t, f); l = (i = t[p]) == null ? void 0 : i.details } return `<details class="custom-container details"><summary>${l || "Details"}</summary>
`}, closeRender: () => `</details>
`}))
  }, Ce = e => { const t = e.renderer.rules.image; e.renderer.rules.image = (o, n, r, s, a) => (o[n].attrSet("loading", "lazy"), t(o, n, r, s, a)) }, we = (e, { light: t = ["gh-light-mode-only", "light"], dark: o = ["gh-dark-mode-only", "dark"] } = {}) => { const n = e.renderer.rules.image; e.renderer.rules.image = (r, s, a, i, l) => { const c = r[s], f = c.attrGet("src"); return f && (t.some(p => f.endsWith(`#${p}`)) ? (c.attrSet("data-mode", "lightmode-only"), c.attrSet("src", f.replace(/#.*?$/, ""))) : o.some(p => f.endsWith(`#${p}`)) && (c.attrSet("data-mode", "darkmode-only"), c.attrSet("src", f.replace(/#.*?$/, "")))), n(r, s, a, i, l) } }, je = (e, t, o) => { let n; const r = t, s = { ok: !1, pos: t, value: "" }; for (n = e.charCodeAt(t); t < o && n >= 48 && n <= 57 || n === 37;)n = e.charCodeAt(++t); return s.ok = !0, s.pos = t, s.value = e.slice(r, t), s }, Ht = (e, t, o) => { const n = { ok: !1, pos: 0, width: "", height: "" }; if (t >= o || e.charAt(t) !== "=") return n; t += 1; const r = e.charCodeAt(t); if (r !== 120 && (r < 48 || r > 57)) return n; const s = je(e, t, o); if (t = s.pos, e.charAt(t) !== "x") return n; t += 1; const a = je(e, t, o); return t = a.pos, n.width = s.value, n.height = a.value, n.pos = t, n.ok = !0, n }, Xt = (e, t) => { const o = e.env, n = e.pos, r = e.posMax; if (e.src.charAt(e.pos) !== "!" || e.src.charAt(e.pos + 1) !== "[") return !1; const s = e.pos + 2, a = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1); if (a < 0) return !1; let i = a + 1, l, c = "", f = "", p = "", b = ""; if (i < r && e.src.charAt(i) === "(") { for (i += 1; i < r && (l = e.src.charCodeAt(i), !(!e.md.utils.isSpace(l) && l !== 10)); i++); if (i >= r) return !1; let m; m = e.md.helpers.parseLinkDestination(e.src, i, e.posMax), m.ok && (c = e.md.normalizeLink(m.str), e.md.validateLink(c) ? i = m.pos : c = ""); const h = i; for (; i < r && (l = e.src.charCodeAt(i), !(!e.md.utils.isSpace(l) && l !== 10)); i++); if (m = e.md.helpers.parseLinkTitle(e.src, i, e.posMax), i < r && h !== i && m.ok) for (f = m.str, i = m.pos; i < r && (l = e.src.charCodeAt(i), !(!e.md.utils.isSpace(l) && l !== 10)); i++); else f = ""; if (i - 1 >= 0 && (l = e.src.charCodeAt(i - 1), l === 32 && (m = Ht(e.src, i, e.posMax), m.ok))) for (p = m.width, b = m.height, i = m.pos; i < r && (l = e.src.charCodeAt(i), !(l !== 32 && l !== 10)); i++); if (i >= r || e.src.charAt(i) !== ")") return e.pos = n, !1; i += 1 } else { let m = ""; if (typeof o.references > "u") return !1; if (i < r && e.src.charAt(i) === "[") { const u = i + 1; i = e.md.helpers.parseLinkLabel(e, i), i >= 0 ? m = e.src.slice(u, i++) : i = a + 1 } else i = a + 1; m || (m = e.src.slice(s, a)); const h = o.references[e.md.utils.normalizeReference(m)]; if (!h) return e.pos = n, !1; c = h.href, f = h.title || "" } if (!t) { const m = e.src.slice(s, a), h = []; e.md.inline.parse(m, e.md, e.env, h); const u = e.push("image", "img", 0); u.attrs = [["src", c], ["alt", ""]], f && u.attrs.push(["title", f]), p !== "" && u.attrs.push(["width", p]), b !== "" && u.attrs.push(["height", b]), u.children = h, u.content = m } return e.pos = i, e.posMax = r, !0 }, Me = e => { e.inline.ruler.before("emphasis", "image", Xt) }, Se = (e, t) => { const o = t > 0 ? e.src.charAt(t - 1) : "", n = t + 1 <= e.posMax ? e.src.charAt(t + 1) : ""; return { canOpen: n !== " " && n !== "	", canClose: !(o === " " || o === "	" || /[0-9]/u.exec(n)) } }, Yt = (e, t) => { let o, n, r, s; if (e.src[e.pos] !== "$") return !1; if (r = Se(e, e.pos), !r.canOpen) return t || (e.pending += "$"), e.pos += 1, !0; const a = e.pos + 1; for (o = a; (o = e.src.indexOf("$", o)) !== -1;) { for (n = o - 1; e.src[n] === "\\";)n -= 1; if ((o - n) % 2 === 1) break; o += 1 } return o === -1 ? (t || (e.pending += "$"), e.pos = a, !0) : o - a === 0 ? (t || (e.pending += "$$"), e.pos = a + 1, !0) : (r = Se(e, o), r.canClose ? (t || (s = e.push("math_inline", "math", 0), s.markup = "$", s.content = e.src.slice(a, o)), e.pos = o + 1, !0) : (t || (e.pending += "$"), e.pos = a, !0)) }, Kt = (e, t, o, n) => {
    let r, s, a, i, l = !1, c = e.bMarks[t] + e.tShift[t], f = e.eMarks[t]; if (c + 2 > f || e.src.slice(c, c + 2) !== "$$") return !1; if (c += 2, r = e.src.slice(c, f), n) return !0; for (r.trim().endsWith("$$") && (r = r.trim().slice(0, -2), l = !0), a = t; !l && (a += 1, !(a >= o || (c = e.bMarks[a] + e.tShift[a], f = e.eMarks[a], c < f && e.tShift[a] < e.blkIndent)));)e.src.slice(c, f).trim().endsWith("$$") && (i = e.src.slice(0, f).lastIndexOf("$$"), s = e.src.slice(c, i), l = !0); e.line = a + 1; const p = e.push("math_block", "math", 0); return p.block = !0, p.content = (r != null && r.trim() ? `
${r}
`: `
`) + e.getLines(t + 1, a, e.tShift[t], !0) + (s != null && s.trim() ? s : ""), p.map = [t, e.line], p.markup = "$$", !0
  }, X = (e, t) => { const { render: o } = t || {}; if (typeof o != "function") return console.error('markdown-it tex: "render" option should be a function'); e.inline.ruler.after("escape", "math_inline", Yt), e.block.ruler.after("blockquote", "math_block", Kt, { alt: ["paragraph", "reference", "blockquote", "list"] }), e.renderer.rules.math_inline = (n, r) => o(n[r].content, !1), e.renderer.rules.math_block = (n, r) => o(n[r].content, !0) }, Zt = /\r\n?|\n/g, Oe = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/gu, Ie = (e, t, o) => { const n = e.attrIndex(t), r = [t, o]; n < 0 ? e.attrPush(r) : e.attrs[n] = r }, Qt = (e, t) => { const o = e[t].level - 1; for (let n = t - 1; n >= 0; n--)if (e[n].level === o) return n; return -1 }, en = e => (e == null ? void 0 : e.type) === "inline", tn = e => (e == null ? void 0 : e.type) === "paragraph_open", nn = e => (e == null ? void 0 : e.type) === "list_item_open", N = e => e.replace(/&/gu, "&amp;").replace(/</gu, "&lt;").replace(/>/gu, "&gt;").replace(/"/gu, "&quot;").replace(/'/gu, "&#039;"), on = re(import.meta.url), rn = (e, t) => { try { return se.renderToString(e, { ...t, displayMode: !1 }) } catch (o) { return t.throwOnError && console.warn(o), `<span class='katex-error' title='${N(o.toString())}'>${N(e)}</span>` } }, sn = (e, t) => {
    try {
      return `<p class='katex-block'>${se.renderToString(e, { ...t, displayMode: !0, strict: o => o === "newLineInDisplayMode" ? "ignore" : "warn" })}</p>
`} catch (o) {
      return t.throwOnError && console.warn(o), `<p class='katex-block katex-error' title='${N(o.toString())}'>${N(e)}</p>
`}
  }, Ae = (e, t = {}) => { const { mhchem: o = !1, ...n } = t; o && on("katex/contrib/mhchem"); const r = { throwOnError: !1, ...n }; e.use(X, { render: (s, a) => a ? sn(s, r) : rn(s, r) }) }, Pe = e => ({ InputJax: new dt({ packages: $t, ...e.tex }), OutputJax: e.output === "chtml" ? new ht({ fontURL: ut(re(import.meta.url).resolve("mathjax-full/es5/output/chtml/fonts/woff-v2/MathJax_Zero.woff")), adaptiveCSS: !0, ...e.chtml }) : new gt({ fontCache: "none", ...e.svg }), enableAssistiveMml: e.a11y !== !1 }), Re = e => { if (!e) return null; const t = typeof e == "object" ? e : {}, o = Pe(t), n = bt(), r = kt(n); return t.a11y !== !1 && yt(r), { adaptor: n, documentOptions: o } }, Te = (e, t) => { const { adaptor: o, documentOptions: n } = t; e.use(X, { render: (r, s) => { const a = ie.document(r, n).convert(r, { display: s }); return o.outerHTML(a) } }) }, an = (e, t) => { const o = e.pos, n = e.src.charAt(o); if (t || n !== "=") return !1; const r = e.scanDelims(e.pos, !0); let { length: s } = r; if (s < 2) return !1; let a; s % 2 && (a = e.push("text", "", 0), a.content = n, s -= 1); for (let i = 0; i < s; i += 2)a = e.push("text", "", 0), a.content = `${n}${n}`, (r.can_open || r.can_close) && e.delimiters.push({ marker: 61, length: 0, jump: i / 2, token: e.tokens.length - 1, end: -1, open: r.can_open, close: r.can_close }); return e.pos += r.length, !0 }, Ee = (e, t) => { let o; const n = [], r = t.length; for (let s = 0; s < r; s++) { const a = t[s]; if (a.marker === 61 && a.end !== -1) { const i = t[a.end]; o = e.tokens[a.token], o.type = "mark_open", o.tag = "mark", o.nesting = 1, o.markup = "==", o.content = "", o = e.tokens[i.token], o.type = "mark_close", o.tag = "mark", o.nesting = -1, o.markup = "==", o.content = "", e.tokens[i.token - 1].type === "text" && e.tokens[i.token - 1].content === "=" && n.push(i.token - 1) } } for (; n.length;) { const s = n.pop(); let a = s + 1; for (; a < e.tokens.length && e.tokens[a].type === "mark_close";)a += 1; a -= 1, s !== a && (o = e.tokens[a], e.tokens[a] = e.tokens[s], e.tokens[s] = o) } }, De = e => { e.inline.ruler.before("emphasis", "mark", an), e.inline.ruler2.before("emphasis", "mark", t => { const o = t.tokens_meta || []; Ee(t, t.delimiters); for (let n = 0; n < o.length; n++) { const r = o[n]; r != null && r.delimiters && Ee(t, r.delimiters) } return !0 }) }, ln = /^@include\(([^)]*?)(?:\{(\d+)?-(\d+)?\})?\)$/, Le = ({ filePath: e, lineStart: t, lineEnd: o }, { cwd: n, includedFiles: r, resolvedPath: s }) => {
    let a = e; if (!S.isAbsolute(e)) {
      if (!n) return console.error(`Include: Error when resolving path: ${e}`), `
Error when resolving path
`; a = S.resolve(n, e)
    } if (r.push(a), !ae.existsSync(a)) return console.error(`Include: ${a} not found`), `
File not found
`; const i = ae.readFileSync(a).toString().replace(Zt, `
`).split(`
`).slice(t && t - 1, o); if (s && a.endsWith(".md")) { const l = S.dirname(a); i.unshift(`@include-push(${l})`), i.push("@include-pop()") } return i.join(`
`).replace(/\n?$/, `
`)
  }, Y = (e, t, { cwd: o, includedFiles: n }) => e.split(`
`).map(r => { if (r.startsWith("@include")) { const s = r.match(ln); if (s) { const [, a, i, l] = s, c = t.getPath(a), f = t.resolveImagePath || t.resolveLinkPath, p = Le({ filePath: c, lineStart: i ? Number.parseInt(i, 10) : 0, lineEnd: l ? Number.parseInt(l, 10) : void 0 }, { cwd: o, includedFiles: n, resolvedPath: f }); return t.deep && c.endsWith(".md") ? Y(p, t, { cwd: S.isAbsolute(c) ? S.dirname(c) : o ? S.resolve(o, S.dirname(c)) : null, includedFiles: n }) : p } } return r }).join(`
`), Ne = e => t => { const o = t.env, n = o.includedFiles || (o.includedFiles = []); t.src = Y(t.src, e, { cwd: o.filePath ? S.dirname(o.filePath) : null, includedFiles: n }) }, cn = /^@include-push\(([^)]*?)\)$/, pn = /^@include-pop\(\)$/, mn = (e, t, o, n) => { const r = e.bMarks[t] + e.tShift[t], s = e.eMarks[t], a = e.src.slice(r, s); let i = a.startsWith("@include-push"); if (i) { const l = a.match(cn); if (l) { if (n) return !0; const [, c] = l; e.line = t + 1; const f = e.push("include_push", "", 0); f.map = [t, e.line], f.info = c, f.markup = "incPush" } else i = !1 } return i }, fn = (e, t, o, n) => { const r = e.bMarks[t] + e.tShift[t], s = e.eMarks[t], a = e.src.slice(r, s); let i = a.startsWith("@include-pop"); if (i) if (a.match(pn)) { if (n) return !0; e.line = t + 1; const l = e.push("include_pop", "", 0); l.map = [t, e.line], l.markup = "incPop" } else i = !1; return i }, Fe = (e, t, o, n) => { var r; const s = t.attrIndex(e), a = (r = t.attrs) == null ? void 0 : r[s][1]; if (a != null && a.startsWith(".") && Array.isArray(n)) { const { length: i } = n; if (i) { const l = S.relative(S.dirname(o), n[i - 1]); t.attrs[s][1] = `.${S.sep}${S.join(l, a)}` } } }, Ue = (e, { getPath: t = s => s, deep: o = !1, resolveLinkPath: n = !0, resolveImagePath: r = !0 } = {}) => { if (e.core.ruler.after("normalize", "md_import", Ne({ getPath: t, deep: o, resolveLinkPath: n, resolveImagePath: r })), r || n) { if (e.block.ruler.before("table", "md_include_push", mn, { alt: ["paragraph", "reference", "blockquote", "list"] }), e.block.ruler.before("table", "md_include_pop", fn, { alt: ["paragraph", "reference", "blockquote", "list"] }), e.renderer.rules.include_push = (s, a, i, l) => { const c = s[a]; return (l.includedPaths || (l.includedPaths = [])).push(c.info), "" }, e.renderer.rules.include_pop = (s, a, i, l) => { const c = l.includedPaths; return Array.isArray(c) ? c.pop() : console.error("Include: include_pop failed, no include_push."), "" }, r) { const s = e.renderer.rules.image; e.renderer.rules.image = (a, i, l, c, f) => { const p = a[i]; return c.filePath && Fe("src", p, c.filePath, c.includedPaths), s(a, i, l, c, f) } } if (n) { const s = e.renderer.rules.link_open || ((a, i, l, c, f) => f.renderToken(a, i, l)); e.renderer.rules.link_open = (a, i, l, c, f) => { const p = a[i]; return c.filePath && Fe("href", p, c.filePath, c.includedPaths), s(a, i, l, c, f) } } } }, ze = (e, t) => { const o = e[t], n = `mermaid-${t}`, { content: r } = o; return `<Mermaid id="${n}" code="${j(r)}"></Mermaid>` }, P = (e, t, o) => `<Mermaid id="mermaid-${o}" code="${j(`${e}
${t.split(`
`).map(n => n ? `  ${n}` : "").join(`
`)}`)}"></Mermaid>`, Je = e => { const t = e.renderer.rules.fence; e.renderer.rules.fence = (...o) => { const [n, r] = o, { content: s, info: a } = n[r]; return a.trim() === "mermaid" ? ze(...o) : a.trim() === "sequence" ? P("sequenceDiagram", s, r) : a.trim() === "class" ? P("classDiagram", s, r) : a.trim() === "state" ? P("stateDiagram-v2", s, r) : a.trim() === "er" ? P("erDiagram", s, r) : a.trim() === "journey" ? P("journey", s, r) : a.trim() === "gantt" ? P("gantt", s, r) : a.trim() === "pie" ? P("pie", s, r) : a.trim() === "git-graph" ? P("gitGraph", s, r) : a.trim() === "c4c" ? P("C4Context", s, r) : a.trim() === "mindmap" ? P("mindmap", s, r) : t(...o) }, e.renderer.rules.mermaid = ze }, Ge = "@", un = ["file", "import", "setting"], dn = e => (t, o, n, r) => { let s = t.bMarks[o] + t.tShift[o], a = t.eMarks[o]; if (t.src[s] !== ":") return !1; let i = s + 1; for (; i <= a && t.src[i] === ":";)i += 1; const l = i - s; if (l < 3) return !1; const c = t.src.slice(s, i), f = t.src.slice(i, a), p = f.trimStart().split(" ", 2)[0], b = f.trimStart().slice(e.length).trim(); if (p.trim() !== e) return !1; if (r) return !0; let m = o, h = !1; for (; m < n && (m += 1, s = t.bMarks[m] + t.tShift[m], a = t.eMarks[m], !(s < a && t.sCount[m] < t.blkIndent));)if (t.src[s] === ":" && t.sCount[m] - t.blkIndent < 4) { for (i = s + 1; i <= a && t.src[i] === ":"; i++); if (i - s >= l && (i = t.skipSpaces(i), i >= a)) { h = !0; break } } const u = t.parentType, g = t.lineMax; t.parentType = `${e}`, t.lineMax = m - (h ? 1 : 0); const _ = t.push(`${e}_open`, "template", 1); _.markup = c, _.block = !0, _.info = b, _.map = [o, m - (h ? 1 : 0)], t.md.block.tokenize(t, o + 1, m - (h ? 1 : 0)); const k = t.push(`${e}_close`, "template", -1); return k.markup = t.src.slice(s, i), k.block = !0, t.parentType = u, t.lineMax = g, t.line = m + (h ? 1 : 0), !0 }, hn = e => (t, o, n, r) => { let s = t.bMarks[o] + t.tShift[o], a = t.eMarks[o]; const i = `${Ge}${e}`; if (t.src.charAt(s) !== "@") return !1; let l; for (l = 0; l < i.length; l++)if (i[l] !== t.src[s + l]) return !1; const c = t.src.slice(s, s + l), f = t.src.slice(s + l, a); if (r) return !0; let p = o, b = !1; for (; p < n && (p += 1, s = t.bMarks[p] + t.tShift[p], a = t.eMarks[p], !(s < a && t.sCount[p] < t.blkIndent));)if (t.src[s] === Ge && t.sCount[p] <= t.sCount[o]) { let _ = !0; for (l = 0; l < i.length; l++)if (i[l] !== t.src[s + l]) { _ = !1; break } if (_) { b = !0, p -= 1; break } } const m = t.parentType, h = t.lineMax; t.parentType = `${e}`, t.lineMax = p; const u = t.push(`${e}_open`, "template", 1); u.block = !0, u.markup = c, u.info = f.trim(), u.map = [o, p], t.md.block.tokenize(t, o + 1, p); const g = t.push(`${e}_close`, "template", -1); return g.block = !0, g.markup = "", t.parentType = m, t.lineMax = h, t.line = p + (b ? 1 : 0), !0 }, F = (e, { name: t = "playground", component: o = "Playground", propsGetter: n } = { name: "playground", component: "Playground", propsGetter: r => ({ key: r.key, title: r.title || "", files: encodeURIComponent(JSON.stringify(r.files)), settings: encodeURIComponent(JSON.stringify(r.settings || {})) }) }) => {
    e.block.ruler.before("fence", `${t}`, dn(t), { alt: ["paragraph", "reference", "blockquote", "list"] }), un.forEach(r => { e.block.ruler.__rules__.find(({ name: s }) => s === "marker") || e.block.ruler.before("fence", "tab", hn(r), { alt: ["paragraph", "reference", "blockquote", "list"] }) }), e.renderer.rules[`${t}_open`] = (r, s) => {
      const { info: a } = r[s], i = { key: vt(`playground${s}-${a}`), title: encodeURIComponent(a), settings: {}, files: {} }; let l = null, c = !1; for (let p = s; p < r.length; p++) { const { block: b, type: m, info: h, content: u } = r[p]; if (b) { if (m === `${t}_close`) break; if (m === `${t}_open`) continue; if (m === "file_open") { if (!h) continue; l = h } else m === "import_open" && (i.importMap = l = h || "import-map.json"); if (m === "setting_open" && (c = !0), m === "setting_close" && (c = !1), m === "file_close" || m === "import_close" || m === "setting_close" || !u) { r[p].type = `${t}_empty`, r[p].hidden = !0; continue } c ? m === "fence" && h === "json" && (i.settings = JSON.parse(u.trim())) : m === "fence" && l && (i.files[l] = { ext: h, content: u }), r[p].type = `${t}_empty`, r[p].hidden = !0 } } const f = n(i); return `<${o} ${Object.entries(f).map(([p, b]) => `${p}="${N(b)}"`).join(" ")}>
`}, e.renderer.rules[`${t}_close`] = () => `</${o}>
`}, gn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", bn = (e, t, o) => { if (e == null) return ""; let n, r, s, a = {}, i = {}, l = "", c = "", f = "", p = 2, b = 3, m = 2, h = [], u = 0, g = 0; for (s = 0; s < e.length; s += 1)if (l = e.charAt(s), Object.prototype.hasOwnProperty.call(a, l) || (a[l] = b++, i[l] = !0), c = f + l, Object.prototype.hasOwnProperty.call(a, c)) f = c; else { if (Object.prototype.hasOwnProperty.call(i, f)) { if (f.charCodeAt(0) < 256) { for (n = 0; m > n; n++)u <<= 1, g == t - 1 ? (g = 0, h.push(o(u)), u = 0) : g++; for (r = f.charCodeAt(0), n = 0; 8 > n; n++)u = u << 1 | 1 & r, g == t - 1 ? (g = 0, h.push(o(u)), u = 0) : g++, r >>= 1 } else { for (r = 1, n = 0; m > n; n++)u = u << 1 | r, g == t - 1 ? (g = 0, h.push(o(u)), u = 0) : g++, r = 0; for (r = f.charCodeAt(0), n = 0; 16 > n; n++)u = u << 1 | 1 & r, g == t - 1 ? (g = 0, h.push(o(u)), u = 0) : g++, r >>= 1 } p--, p == 0 && (p = Math.pow(2, m), m++), delete i[f] } else for (r = a[f], n = 0; m > n; n++)u = u << 1 | 1 & r, g == t - 1 ? (g = 0, h.push(o(u)), u = 0) : g++, r >>= 1; p--, p == 0 && (p = Math.pow(2, m), m++), a[c] = b++, f = String(l) } if (f !== "") { if (Object.prototype.hasOwnProperty.call(i, f)) { if (f.charCodeAt(0) < 256) { for (n = 0; m > n; n++)u <<= 1, g == t - 1 ? (g = 0, h.push(o(u)), u = 0) : g++; for (r = f.charCodeAt(0), n = 0; 8 > n; n++)u = u << 1 | 1 & r, g == t - 1 ? (g = 0, h.push(o(u)), u = 0) : g++, r >>= 1 } else { for (r = 1, n = 0; m > n; n++)u = u << 1 | r, g == t - 1 ? (g = 0, h.push(o(u)), u = 0) : g++, r = 0; for (r = f.charCodeAt(0), n = 0; 16 > n; n++)u = u << 1 | 1 & r, g == t - 1 ? (g = 0, h.push(o(u)), u = 0) : g++, r >>= 1 } p--, p == 0 && (p = Math.pow(2, m), m++), delete i[f] } else for (r = a[f], n = 0; m > n; n++)u = u << 1 | 1 & r, g == t - 1 ? (g = 0, h.push(o(u)), u = 0) : g++, r >>= 1; p--, p == 0 && (p = Math.pow(2, m), m++) } for (r = 2, n = 0; m > n; n++)u = u << 1 | 1 & r, g == t - 1 ? (g = 0, h.push(o(u)), u = 0) : g++, r >>= 1; for (; ;) { if (u <<= 1, g == t - 1) { h.push(o(u)); break } g++ } return h.join("") }, yn = e => bn(e, 6, t => gn.charAt(t)), kn = [{ name: "help", type: "boolean" }, { name: "help", type: "boolean" }, { name: "watch", type: "boolean" }, { name: "preserveWatchOutput", type: "boolean" }, { name: "listFiles", type: "boolean" }, { name: "explainFiles", type: "boolean" }, { name: "listEmittedFiles", type: "boolean" }, { name: "pretty", type: "boolean" }, { name: "traceResolution", type: "boolean" }, { name: "diagnostics", type: "boolean" }, { name: "extendedDiagnostics", type: "boolean" }, { name: "generateCpuProfile", type: "string" }, { name: "generateTrace", type: "string" }, { name: "incremental", type: "boolean" }, { name: "assumeChangesOnlyAffectDirectDependencies", type: "boolean" }, { name: "locale", type: "string" }, { name: "all", type: "boolean" }, { name: "version", type: "boolean" }, { name: "init", type: "boolean" }, { name: "project", type: "string" }, { name: "build", type: "boolean" }, { name: "showConfig", type: "boolean" }, { name: "listFilesOnly", type: "boolean" }, { name: "target", type: { es3: 0, es5: 1, es6: 2, es2015: 2, es2016: 3, es2017: 4, es2018: 5, es2019: 6, es2020: 7, es2021: 8, es2022: 9, esnext: 99 } }, { name: "module", type: { none: 0, commonjs: 1, amd: 2, system: 4, umd: 3, es6: 5, es2015: 5, es2020: 6, es2022: 7, esnext: 99, node16: 100, nodenext: 199 } }, { name: "lib", type: "list" }, { name: "allowJs", type: "boolean" }, { name: "checkJs", type: "boolean" }, { name: "jsx", type: { preserve: 1, "react-native": 3, react: 2, "react-jsx": 4, "react-jsxdev": 5 } }, { name: "declaration", type: "boolean" }, { name: "declarationMap", type: "boolean" }, { name: "emitDeclarationOnly", type: "boolean" }, { name: "sourceMap", type: "boolean" }, { name: "outFile", type: "string" }, { name: "outDir", type: "string" }, { name: "rootDir", type: "string" }, { name: "composite", type: "boolean" }, { name: "tsBuildInfoFile", type: "string" }, { name: "removeComments", type: "boolean" }, { name: "noEmit", type: "boolean" }, { name: "importHelpers", type: "boolean" }, { name: "importsNotUsedAsValues", type: { remove: 0, preserve: 1, error: 2 } }, { name: "downlevelIteration", type: "boolean" }, { name: "isolatedModules", type: "boolean" }, { name: "strict", type: "boolean" }, { name: "noImplicitAny", type: "boolean" }, { name: "strictNullChecks", type: "boolean" }, { name: "strictFunctionTypes", type: "boolean" }, { name: "strictBindCallApply", type: "boolean" }, { name: "strictPropertyInitialization", type: "boolean" }, { name: "noImplicitThis", type: "boolean" }, { name: "useUnknownInCatchVariables", type: "boolean" }, { name: "alwaysStrict", type: "boolean" }, { name: "noUnusedLocals", type: "boolean" }, { name: "noUnusedParameters", type: "boolean" }, { name: "exactOptionalPropertyTypes", type: "boolean" }, { name: "noImplicitReturns", type: "boolean" }, { name: "noFallthroughCasesInSwitch", type: "boolean" }, { name: "noUncheckedIndexedAccess", type: "boolean" }, { name: "noImplicitOverride", type: "boolean" }, { name: "noPropertyAccessFromIndexSignature", type: "boolean" }, { name: "moduleResolution", type: { node: 2, classic: 1, node16: 3, nodenext: 99 } }, { name: "baseUrl", type: "string" }, { name: "paths", type: "object" }, { name: "rootDirs", type: "list" }, { name: "typeRoots", type: "list" }, { name: "types", type: "list" }, { name: "allowSyntheticDefaultImports", type: "boolean" }, { name: "esModuleInterop", type: "boolean" }, { name: "preserveSymlinks", type: "boolean" }, { name: "allowUmdGlobalAccess", type: "boolean" }, { name: "moduleSuffixes", type: "list" }, { name: "sourceRoot", type: "string" }, { name: "mapRoot", type: "string" }, { name: "inlineSourceMap", type: "boolean" }, { name: "inlineSources", type: "boolean" }, { name: "experimentalDecorators", type: "boolean" }, { name: "emitDecoratorMetadata", type: "boolean" }, { name: "jsxFactory", type: "string" }, { name: "jsxFragmentFactory", type: "string" }, { name: "jsxImportSource", type: "string" }, { name: "resolveJsonModule", type: "boolean" }, { name: "out", type: "string" }, { name: "reactNamespace", type: "string" }, { name: "skipDefaultLibCheck", type: "boolean" }, { name: "charset", type: "string" }, { name: "emitBOM", type: "boolean" }, { name: "newLine", type: { crlf: 0, lf: 1 } }, { name: "noErrorTruncation", type: "boolean" }, { name: "noLib", type: "boolean" }, { name: "noResolve", type: "boolean" }, { name: "stripInternal", type: "boolean" }, { name: "disableSizeLimit", type: "boolean" }, { name: "disableSourceOfProjectReferenceRedirect", type: "boolean" }, { name: "disableSolutionSearching", type: "boolean" }, { name: "disableReferencedProjectLoad", type: "boolean" }, { name: "noImplicitUseStrict", type: "boolean" }, { name: "noEmitHelpers", type: "boolean" }, { name: "noEmitOnError", type: "boolean" }, { name: "preserveConstEnums", type: "boolean" }, { name: "declarationDir", type: "string" }, { name: "skipLibCheck", type: "boolean" }, { name: "allowUnusedLabels", type: "boolean" }, { name: "allowUnreachableCode", type: "boolean" }, { name: "suppressExcessPropertyErrors", type: "boolean" }, { name: "suppressImplicitAnyIndexErrors", type: "boolean" }, { name: "forceConsistentCasingInFileNames", type: "boolean" }, { name: "maxNodeModuleJsDepth", type: "number" }, { name: "noStrictGenericChecks", type: "boolean" }, { name: "useDefineForClassFields", type: "boolean" }, { name: "preserveValueImports", type: "boolean" }, { name: "keyofStringsOnly", type: "boolean" }, { name: "plugins", type: "list" }, { name: "moduleDetection", type: { auto: 2, legacy: 1, force: 3 } }], We = (e, t = {}) => { const o = `#code/${yn(e)}`, n = Object.entries(t).map(([r, s]) => { const a = kn.find(l => l.name === r); if (!a || s === null || s === void 0) return ""; const { type: i } = a; if (typeof i == "object") { const l = i[s]; return (l == null ? void 0 : l.toString()) || "" } return `${r}=${encodeURIComponent(s)}` }).filter(r => r.length).join("&"); return `${n ? `?${n}` : ""}${o}` }, Be = ({ service: e = "https://www.typescriptlang.org/play", ...t } = {}) => ({ name: "playground#ts", propsGetter: ({ title: o = "", files: n, settings: r, key: s }) => { const a = Object.keys(n).filter(l => l.endsWith(".ts")); a.length !== 1 && console.error("TS playground only support 1 ts file"); const i = `${e}${We(n[a[0]].content, W({}, r || {}, t))}`; return { key: s, title: o, link: encodeURIComponent(i) } } }), $n = ["html", "js", "ts", "vue", "jsx", "tsx", "json"], Ve = "https://sfc.vuejs.org/vue.runtime.esm-browser.js", qe = "https://sfc.vuejs.org/server-renderer.esm-browser.js", He = (e = {}) => ({ name: "playground#vue", propsGetter: t => { const { title: o = "", files: n, settings: r, key: s } = t, a = { service: "https://sfc.vuejs.org/", dev: !1, ssr: !1, ...e, ...r }, i = Object.fromEntries(Object.entries(n).filter(([, { ext: l }]) => $n.includes(l)).map(([l, { content: c }]) => { if (l === "import-map.json") { const f = JSON.parse(c); return [l, JSON.stringify(W({ imports: { vue: Ve, ...a.ssr ? { "vue/server-renderer": qe } : {} } }, f))] } return [l, c] })); return a.ssr && !i["import-map.json"] && (i["import-map.json"] = JSON.stringify({ imports: { vue: Ve, "vue/server-renderer": qe } }, null, 2)), { key: s, title: o, link: encodeURIComponent(`${a.service}#${a.dev ? "__DEV__" : ""}${a.ssr ? "__SSR__" : ""}${Buffer.from(JSON.stringify(i)).toString("base64")}`) } } }), K = (e, { name: t, open: o, close: n, render: r } = { name: "uml", open: "start", close: "end", render: (s, a) => { const i = s[a], { content: l, info: c, type: f } = i; return `<div class="${f}" title="${c}">${l}</div>` } }) => {
    const s = `@${o}`, a = `@${n}`, i = (l, c, f, p) => {
      let b, m = !1, h = l.bMarks[c] + l.tShift[c], u = l.eMarks[c]; if (l.src.charAt(h) !== "@") return !1; for (b = 0; b < s.length; ++b)if (s[b] !== l.src[h + b]) return !1; const g = l.src.slice(h, h + b), _ = l.src.slice(h + b, u); if (p) return !0; let k = c; for (; k < f && (h = l.bMarks[k] + l.tShift[k], u = l.eMarks[k], !(h < u && l.sCount[k] < l.blkIndent));) { if (l.src.charAt(h) === "@" && l.sCount[k] <= l.sCount[c]) { let d = !0; for (b = 0; b < a.length; ++b)if (a[b] !== l.src[h + b]) { d = !1; break } if (d && l.skipSpaces(h + b) >= u) { m = !0; break } } k += 1 } const $ = l.src.split(`
`).slice(c + 1, k).join(`
`), v = l.push(t, "fence", 0); return v.block = !0, v.info = _, v.content = $, v.map = [c, k], v.markup = g, l.line = k + (m ? 1 : 0), !0
    }; e.block.ruler.before("fence", t, i, { alt: ["paragraph", "reference", "blockquote", "list"] }), e.renderer.rules[t] = r
  }, Xe = e => { e.use(K, { name: "presentation", open: "slidestart", close: "slideend", render: (t, o) => { const n = t[o], r = `presentation-${o}`, { content: s, info: a } = n; return `<Presentation id="${r}" code="${j(s)}" theme="${a.trim() || "auto"}"></Presentation>` } }) }, vn = (e, t) => { let o, n; const r = e.posMax, s = e.pos; if (e.src.charAt(s) !== "~" || t || s + 2 >= r) return !1; for (e.pos = s + 1; e.pos < r;) { if (e.src.charAt(e.pos) === "~") { o = !0; break } e.md.inline.skipToken(e) } if (!o || s + 1 === e.pos) return e.pos = s, !1; const a = e.src.slice(s + 1, e.pos); return /(^|[^\\])(\\\\)*\s/u.exec(a) ? (e.pos = s, !1) : (e.posMax = e.pos, e.pos = s + 1, n = e.push("sub_open", "sub", 1), n.markup = "~", n = e.push("text", "", 0), n.content = a.replace(Oe, "$1"), n = e.push("sub_close", "sub", -1), n.markup = "~", e.pos = e.posMax + 1, e.posMax = r, !0) }, Ye = e => { e.inline.ruler.after("emphasis", "sub", vn) }, _n = (e, t) => { let o, n; const r = e.posMax, s = e.pos; if (e.src.charAt(s) !== "^" || t || s + 2 >= r) return !1; for (e.pos = s + 1; e.pos < r;) { if (e.src.charAt(e.pos) === "^") { o = !0; break } e.md.inline.skipToken(e) } if (!o || s + 1 === e.pos) return e.pos = s, !1; const a = e.src.slice(s + 1, e.pos); return /(^|[^\\])(\\\\)*\s/u.exec(a) ? (e.pos = s, !1) : (e.posMax = e.pos, e.pos = s + 1, n = e.push("sup_open", "sup", 1), n.markup = "^", n = e.push("text", "", 0), n.content = a.replace(Oe, "$1"), n = e.push("sup_close", "sup", -1), n.markup = "^", e.pos = e.posMax + 1, e.posMax = r, !0) }, Ke = e => { e.inline.ruler.after("emphasis", "sup", _n) }, xn = e => /^\[[xX \u00A0]\][ \u00A0]/.test(e.content), Cn = (e, t) => en(e[t]) && tn(e[t - 1]) && nn(e[t - 2]) && xn(e[t]), wn = (e, t, o = !0) => { const n = new M("checkbox_input", "input", 0); return n.attrs = [["type", "checkbox"], ["class", "task-list-item-checkbox"], ["id", t]], /^\[[xX]\][ \u00A0]/.test(e.content) && n.attrs.push(["checked", "checked"]), o && n.attrs.push(["disabled", "disabled"]), n }, jn = e => { const t = new M("label_open", "label", 1); return t.attrs = [["class", "task-list-item-label"], ["for", e]], t }, Mn = () => new M("label_close", "label", -1), Sn = (e, t, o) => { const n = `task-item-${t.env.tasklists++}`; e.children = e.children || [], e.children[0].content = e.children[0].content.slice(3), o.label && (e.children.unshift(jn(n)), e.children.push(Mn())), e.children.unshift(wn(e, n, o.disabled)) }, Ze = (e, { disabled: t = !0, label: o = !0 } = {}) => { e.core.ruler.after("inline", "github-task-lists", n => { const r = n.tokens; n.env.tasklists || (n.env.tasklists = 0); for (let s = 2; s < r.length; s++)Cn(r, s) && (Sn(r[s], n, { disabled: t, label: o }), Ie(r[s - 2], "class", "task-list-item"), Ie(r[Qt(r, s - 2)], "class", "task-list-container")); return !0 }) }, Qe = e => {
    O(e, {
      name: "v-pre", openRender: () => `<div v-pre>
`, closeRender: () => `</div>
`})
  }, On = (e, t, o = []) => { for (let n = 1, r = e.length; n < r - 1; n++) { const s = e[n], { content: a, type: i } = s; if (i !== "text" || o.includes(a)) continue; const l = t.find(({ matcher: p }) => typeof p == "string" ? p === a : p.test(a)), c = e[n - 1], f = e[n + 1]; if (l && c.tag === f.tag && c.nesting === 1 && f.nesting === -1) { const p = l.replacer({ tag: c.tag, content: s.content, attrs: Object.fromEntries(c.attrs || []) }); p && (c.tag = f.tag = p.tag, c.attrs = Object.entries(p.attrs), s.content = p.content), n += 2 } } }, et = (e, t = []) => { Object.keys(t).length != 0 && e.core.ruler.push("stylize_tag", ({ env: o, tokens: n }) => { const { noStylize: r } = o.frontmatter || {}; n.forEach(({ type: s, children: a }) => { s === "inline" && On(a || [], t, r) }) }) }, Z = { autoResize: !0, showCode: !1, showCompileOutput: !1, showImportMap: !0, clearConsole: !1, layout: "vertical", ssr: !1 }, In = ["html", "js", "ts", "vue", "jsx", "tsx", "json"], An = e => Buffer.from(JSON.stringify(Object.fromEntries(Object.entries(e).filter(([, { ext: t }]) => In.includes(t)).map(([t, o]) => [t, o.content])))).toString("base64"), tt = e => { e.use(F, { name: "vue-playground", component: "VuePlayground", propsGetter: ({ title: t = "", key: o, files: n, settings: r }) => ({ title: t, key: o, settings: encodeURIComponent(JSON.stringify(r || {})), files: encodeURIComponent(An(n)) }) }) }, nt = { "/en/": { info: "Info", note: "Note", tip: "Tips", warning: "Note", danger: "Warning", details: "Details" }, "/zh/": { info: "相关信息", note: "注", tip: "提示", warning: "注意", danger: "警告", details: "详情" }, "/zh-tw/": { info: "相關信息", note: "注", tip: "提示", warning: "注意", danger: "警告", details: "詳情" }, "/de-at/": { info: "Information", note: "Note", tip: "Tips", warning: "Notiz", danger: "Warnung", details: "Details" }, "/vi/": { info: "Thông tin", note: "Note", tip: "Tips", warning: "Lưu ý", danger: "Cẩn thận", details: "Chi tiết" }, "/uk/": { info: "Інформація", note: "Note", tip: "Поради", warning: "Примітка", danger: "Увага", details: "Деталь" }, "/ru/": { info: "Инфо", note: "Заметка", tip: "Совет", warning: "Примечание", danger: "Предупреждение", details: "Подробности" }, "/br/": { info: "Informativo", note: "Note", tip: "Dicas", warning: "Avisos", danger: "Cuidado", details: "Detalhe" }, "/pl/": { info: "Info", note: "Notatka", tip: "Porady", warning: "Notatka", danger: "Ostrzeżenie", details: "Dane" }, "/sk/": { info: "Info", note: "Poznámka", tip: "Tip", warning: "Upozornenie", danger: "Pozor", details: "Podrobnosti" }, "/fr/": { info: "Info", note: "Note", tip: "Conseil", warning: "Note", danger: "Avertissement", details: "Details" }, "/es/": { info: "Información", note: "Nota", tip: "Consejos", warning: "Aviso", danger: "Advertencia", details: "Detalles" }, "/ja/": { info: "関連情報", note: "注", tip: "ヒント", warning: "注意", danger: "警告", details: "詳細" }, "/tr/": { info: "Bilgi", note: "Not", tip: "Tavsiye", warning: "Uyarı", danger: "Tehlike", details: "Detay" }, "/ko/": { info: "정보", note: "노트", tip: "팁", warning: "경고", danger: "위험", details: "세부사항" } }, Pn = _t(import.meta.url), ot = ["math", "maction", "maligngroup", "malignmark", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mlongdiv", "mmutiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mscarries", "mscarry", "msgroup", "msline", "mspace", "msqrt", "msrow", "mstack", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "semantics", "annotation", "annotation-xml"], G = new it("vuepress-plugin-md-enhance"), w = ft(S.resolve(Pn, "../client")), Rn = (e, t) => { const { linkCheck: o = "dev" } = t; return typeof o == "boolean" ? o : o === "always" || e.env.isDev && o === "dev" || e.env.isBuild && o === "build" || !1 }, rt = (e, t) => { const o = e.filePathRelative || e.path, { pages: n } = t, r = e.links.filter(({ raw: a }) => a.match(/.md((?:\?|#).*)?$/)), s = [...r.filter(({ raw: a }) => !a.startsWith("/")).filter(({ relative: a }) => n.every(({ filePathRelative: i }) => i !== decodeURI(a))), ...r.filter(({ raw: a }) => a.startsWith("/")).filter(({ absolute: a }) => n.every(({ filePathRelative: i }) => !i || `${t.options.base}${i}` !== decodeURI(a)))].map(({ raw: a }) => a); s.length && xt.warn(`Broken links found in ${o}: ${s.join(", ")}`) }, D = ({ options: e, deprecatedOption: t, newOption: o, msg: n = "", scope: r = "" }) => {
    if (t in e) {
      if (G.warn(`${E.magenta(t)} is ${E.yellow("deprecated")}${r ? ` in ${r}` : ""}, please use "${E.magenta(o)}" instead.${n ? `
${n}` : ""}`), o.includes(".")) { const s = o.split("."); let a = e; s.forEach((i, l) => { l !== s.length - 1 ? (a[i] = a[i] || {}, a = a[i]) : a[i] = e[t] }) } else e[o] = e[t]; delete e[t]
    }
  }, Q = (e, t, o = "", n = "") => {
    t in e && (G.error(`"${E.magenta(t)}" is ${E.red("removed")}${n ? `, please use ${E.magenta(n)} instead.` : " and no longer supported"}${o ? `
${o}` : ""}`), n || delete e[t])
  }, Tn = e => { D({ options: e, deprecatedOption: "codegroup", newOption: "codetabs" }), D({ options: e, deprecatedOption: "lazyload", newOption: "imageLazyload" }), D({ options: e, deprecatedOption: "mdImport", newOption: "include" }), D({ options: e, deprecatedOption: "tex", newOption: "katex" }), D({ options: e, deprecatedOption: "vpre", newOption: "vPre" }), D({ options: e, deprecatedOption: "imageTitle", newOption: "figure" }), Q(e, "enableAll"), Q(e, "lineNumbers"), Q(e, "imageFix") }, En = e => {
    e.use(O, {
      name: "demo", openRender: (t, o) => {
        const { info: n } = t[o], r = /\[(.*)\]/u.exec(n), s = /^ demo\s*(?:\[.*?\])?\s*(.*)\s*$/u.exec(n); let a = ""; const i = {}; for (let l = o; l < t.length; l++) { const { type: c, content: f, info: p } = t[l]; if (c === "container_demo_close") break; f && c === "fence" && (p === "json" ? a = j(f) : i[p] = f) } return `
<CodeDemo id="code-demo-${o}" type="${(r == null ? void 0 : r[1]) || "normal"}"${s ? ` title="${encodeURIComponent(s[1])}"` : ""}${a ? ` config="${a}"` : ""} code="${j(JSON.stringify(i))}">
`}, closeRender: () => "</CodeDemo>"
    })
  }, Dn = e => {
    e.use(O, {
      name: "code-group", openRender: (t, o, n, r) => (G.warn(`Deprecated code-group syntax found${r.filePathRelative ? `in ${r.filePathRelative}` : ""}`), `<CodeGroup>
`), closeRender: () => `</CodeGroup>
`}), e.use(O, {
        name: "code-group-item", openRender: (t, o) => {
          const { info: n } = t[o], r = n.split(":").pop() === "active"; return `<CodeGroupItem title="${r ? n.replace(/:active$/, "") : n}"${r ? " active" : ""}>
`}, closeRender: () => `</CodeGroupItem>
`})
  }, Ln = e => { K(e, { name: "flowchart", open: "flowstart", close: "flowend", render: (t, o) => { console.warn('"@flowstart ... @flowend" is deprecated, you should use ```flow ... ``` instead.'); const n = t[o], r = `flowchart-${o}`, { content: s, info: a } = n; return `<FlowChart id="${r}" code="${j(s)}" preset="${a.trim() || "vue"}"></FlowChart>` } }) }, Nn = async (e, t, o = !1) => {
    let n = "", r = ""; const s = (a, i = !1) => a in t ? Boolean(t[a]) : i && "gfm" in t && t.gfm || !1; return s("chart") && (n += `import ChartJS from "${w}components/ChartJS.js";
`, r += `app.component("ChartJS", ChartJS);
`), s("codetabs") && (n += `import CodeTabs from "${w}components/CodeTabs.js";
`, r += `app.component("CodeTabs", CodeTabs);
`, o && (n += `import { CodeGroup, CodeGroupItem } from "${w}compact/index.js";
`, r += `app.component("CodeGroup", CodeGroup);
app.component("CodeGroupItem", CodeGroupItem);
`)), s("container") && (n += `import "${w}styles/container/index.scss";
`), s("demo") && (n += `import CodeDemo from "${w}components/CodeDemo.js";
`, r += `app.component("CodeDemo", CodeDemo);
`), s("echarts") && (n += `import ECharts from "${w}components/ECharts.js";
`, r += `app.component("ECharts", ECharts);
`), s("figure", !0) && (n += `import "${w}styles/figure.scss";
`), s("flowchart") && (n += `import FlowChart from "${w}components/FlowChart.js";
`, r += `app.component("FlowChart", FlowChart);
`), s("footnote", !0) && (n += `import "${w}styles/footnote.scss";
`), s("imageMark", !0) && (n += `import "${w}styles/image-mark.scss";
`), s("mermaid") && (n += `import Mermaid from "${w}components/Mermaid.js";
`, r += `app.component("Mermaid", Mermaid);
`), s("presentation") && (n += `import Presentation from "${w}components/Presentation.js";
`, r += `app.component("Presentation", Presentation);
`), s("playground") && (n += `import Playground from "${w}components/Playground.js";
`, r += `app.component("Playground", Playground);
`), s("tabs") && (n += `import Tabs from "${w}components/Tabs.js";
`, r += `app.component("Tabs", Tabs);
`), s("tasklist", !0) && (n += `import "${w}styles/tasklist.scss";
`), s("katex") && (n += `import "${w}styles/katex.scss";
`), s("vuePlayground") && (n += `import { defineAsyncComponent } from "vue";
`, r += `app.component("VuePlayground", defineAsyncComponent(() => import("${w}components/VuePlayground.js")));
    `), s("mathjax") && (n += `import "./mathjax.css";
`), e.writeTemp("md-enhance/config.js", `import { defineClientConfig } from "@vuepress/client";
${n}

export default defineClientConfig({
  enhance: ({ app }) => {
${r.split(`
`).map(a => `    ${a}`).join(`
`)}
  },
});
`)
  }, Fn = async (e, { adaptor: t, documentOptions: o }) => { await e.writeTemp("md-enhance/mathjax.css", t.innerHTML(o.OutputJax.styleSheet(ie.document("", o)))) }, Un = async (e, t) => {
    const o = ["reveal", "revealMarkdown", ...t.map(n => `reveal${n[0].toUpperCase()}${n.substring(1)}`)]; await e.writeTemp("md-enhance/reveal.js", `import { ${o.join(", ")} } from "${w}reveal/index.js";

export const useReveal = () => [${o.map(n => `${n}()`).join(", ")}];
`)
  }, zn = (e = { gfm: !0 }, t = !1) => o => { t && Tn(e), o.env.isDebug && G.info("Options:", e); const n = (d, y = !1) => d in e ? Boolean(e[d]) : y && "gfm" in e && e.gfm || !1, r = at({ app: o, name: "md-enhance", default: nt, config: e.locales }), s = n("chart"), a = n("echarts"), i = n("flowchart"), l = n("footnote", !0), c = n("imageMark", !0), f = n("tasklist", !0), p = n("mermaid"), b = n("presentation"), m = n("katex"), h = n("mathjax"), u = n("vuePlayground"), g = Rn(o, e), _ = { macros: { "\\liiiint": "\\int\\!\\!\\!\\iiint", "\\iiiint": "\\int\\!\\!\\!\\!\\iiint", "\\idotsint": "\\int\\!\\cdots\\!\\int" }, ...typeof e.katex == "object" ? e.katex : {} }, k = Re(e.mathjax), $ = typeof e.presentation == "object" && Array.isArray(e.presentation.plugins) ? e.presentation.plugins : []; Ct(o, { id: "hope" }); let v = !1; return { name: "vuepress-plugin-md-enhance", define: () => ({ MARKDOWN_ENHANCE_DELAY: e.delay || 500, CODE_DEMO_OPTIONS: { ...fe, ...typeof e.demo == "object" ? e.demo : {} }, MERMAID_OPTIONS: typeof e.mermaid == "object" ? e.mermaid : {}, REVEAL_CONFIG: typeof e.presentation == "object" && typeof e.presentation.revealConfig == "object" ? e.presentation.revealConfig : {}, VUE_PLAYGROUND_OPTIONS: typeof e.vuePlayground == "object" ? W({}, Z, e.vuePlayground) : Z }), extendsBundlerOptions: (d, y) => { const { bundler: C } = y.options; if (C.name.endsWith("vite")) { const x = d; x.viteOptions = lt(x.viteOptions || {}, { build: { rollupOptions: { onwarn(ee, st) { ee.message.includes("Use of eval") || st(ee) } } } }) } ct({ app: y, config: d }, ["fflate", "vuepress-shared"]), m && _.output !== "html" ? B({ app: y, config: d }, ot) : h && (B({ app: y, config: d }, /^mjx-/), k != null && k.documentOptions.enableAssistiveMml && B({ app: y, config: d }, ot)), s && (U({ app: y, config: d }, "chart.js/auto/auto.mjs"), T({ app: y, config: d }, "chart.js")), a && (U({ app: y, config: d }, "echarts"), T({ app: y, config: d }, "echarts")), i && (te({ app: y, config: d }, "flowchart.js/src/flowchart.parse.js"), T({ app: y, config: d }, "flowchart.js")), p && (U({ app: y, config: d }, "mermaid"), T({ app: y, config: d }, "mermaid")), b && (U({ app: y, config: d }, ["reveal.js/dist/reveal.esm.js", "reveal.js/plugin/markdown/markdown.esm.js", ...$.map(x => `reveal.js/plugin/${x}/${x}.esm.js`)]), T({ app: y, config: d }, "reveal.js")), u && (te({ app: y, config: d }, "@vue/repl"), T({ app: y, config: d }, "@vue/repl"), pt({ app: y, config: d }, x => { x.module.set("exprContextCritical", !1), x.module.set("unknownContextCritical", !1) })) }, extendsMarkdown: d => { if (n("gfm") && (d.options.linkify = !0), n("attrs") && d.use(pe, typeof e.attrs == "object" ? e.attrs : {}), n("align") && d.use(le), n("container") && d.use(xe, r), n("imageLazyload") && d.use(Ce), n("figure") && d.use(ke), c && d.use(we, typeof e.imageMark == "object" ? e.imageMark : {}), n("imageSize") && d.use(Me), n("sup") && d.use(Ke), n("sub") && d.use(Ye), l && d.use(_e), n("mark") && d.use(De), f && d.use(Ze, [typeof e.tasklist == "object" ? e.tasklist : {}]), (n("vPre") || t) && d.use(Qe), m ? d.use(Ae, _) : h && d.use(Te, k), n("include") && d.use(Ue, typeof e.include == "object" ? e.include : {}), n("stylize") && d.use(et, e.stylize), n("codetabs") && (d.use(ge), t && d.use(Dn)), n("tabs") && d.use(H), i && (d.use(ve), t && d.use(Ln)), s && d.use(me), a && d.use(ye), n("demo") && (d.use(ue), d.use(de), d.use(he), t && d.use(En)), p && d.use(Je), b && d.use(Xe), typeof e.playground == "object") { const { presets: y = [], config: C = {} } = e.playground; y.forEach(x => { x === "ts" ? d.use(F, Be(C.ts || {})) : x === "vue" ? d.use(F, He(C.vue || {})) : typeof x == "object" && d.use(F, x) }) } u && d.use(tt) }, extendsPage: (d, y) => { g && v && rt(d, y) }, onInitialized: d => { v = !0, g && d.pages.forEach(y => rt(y, d)) }, onPrepared: async d => Promise.all([h ? Fn(d, k) : Promise.resolve(), Un(d, $)]).then(() => { }), clientConfigFile: d => Nn(d, e, t) } }; export { mo as CHTML, fe as CODE_DEMO_DEFAULT_SETTING, Z as DEFAULT_VUE_PLAYGROUND_OPTIONS, ao as MathJax, uo as SVG, co as TeX, le as align, pe as attrs, me as chart, ge as codeTabs, O as container, Ne as createIncludeCoreRule, ye as echarts, ke as figure, ve as flowchart, _e as footnote, Pe as getDocumentOptions, Be as getTSPlaygroundPreset, We as getURL, He as getVuePlaygroundPreset, Le as handleInclude, xe as hint, Ce as imageLazyload, we as imageMark, Me as imageSize, Ue as include, Re as initMathjax, Ae as katex, De as mark, nt as markdownEnhanceLocales, Te as mathjax, zn as mdEnhancePlugin, Je as mermaid, ue as normalDemo, F as playground, Xe as presentation, he as reactDemo, Y as resolveInclude, et as stylize, Ye as sub, Ke as sup, H as tabs, Ze as tasklist, X as tex, K as uml, Qe as vPre, de as vueDemo, tt as vuePlayground };
//# sourceMappingURL=index.js.map
